=========================
Unit tests are modular by nature.
They test the public API of one member of your application, and mock out the behaviour of other members.

Therefore when writing unit tests, even in a language as unmodular in design as J, the modular nature of large applications should be supported in test.
=========================
When a test runs, it should be clear:

- The name of the test
- Whether it passed or failed

When a test fails, it should be clear:

- Exactly which assertion failed
- The precise difference between the expected value(s) and the actual value(s)

When a test passes, it should be clear:

- It did pass
=========================
How I'd expect to write a simple test in J:

  canPushItemOntoStack = 0 : 0
stack =: 0
push 1 2 3
stack shouldEqual 1 2 3 0
)

NB. On pass:

  canPushItemOntoStack
canPushItemOntoStack: PASS

NB. On failure:
  canPushItemOntoStack
canPushItemOntoStack: FAIL
  Expected: <1 2 3 0>
  Got:      <3 2 1 0>

And for modularity, maybe some tool that runs functions of a certain name: eg:

  runTests 'canPushItemOntoStack' 'canDropItemOffStack' 'canClearStack'
canPushItemOntoStack: PASS
canDropItemOffStack: PASS
canClearStack: PASS
=========================
A good build has a few features:

It tells you:
Which files/artifacts have been loaded/assembled
Whether the tests passed or failed
If the build passed or failed, and if it failed, at what stage it failed.
Which version is being built
The dependencies that have been loaded

Additional features:

It may also tell you:
How long it took
Who ran it
What changes there were from the last build
